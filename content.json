{"pages":[{"title":"about","text":"Hello, My ID：Devnan (Dev：开发者，nan：阿南)Location：广州WeChat：qq742890434","link":"/about/index.html"}],"posts":[{"title":"2019年总结","text":"新环境与思考过来新环境一个多月了，工作上还算充实。有输入有输出，整体感觉很棒，也还需要继续加油。年底的时候换环境，看起来是比较吃亏的，所以之前是下了一个比较大的决心，就为了快速渡过自己的瓶颈期。我自己的理解是，技术人所谓的瓶颈期并不是技术本身的瓶颈，而是外部环境带给人的认知上的瓶颈。一个技术人在某一个狭小的环境待久了，很可能以为这是技术的全部；在一个地方拧螺丝很熟练，很容易散失对技术的好奇心，没有了之前那股冲劲。所以工作前几年，我还是想尽量扩大自己的技术视野，当业务的发展已经满足不了自身的成长，我知道是时候要换环境了。 2019回顾2019年，总体过得还好，比上一年有进步。但是这一年定下的目标也只完成了部分，还是比较懒的。年初定的目标是看完n本技术书，后面一想也没什么意义，因为平时看技术书都是按照章节或主题来看的，而不是一本本来，很难衡量完成情况。所以干脆就不按目标来，想看、需要看就翻一翻书。2019最迷茫的时候应该是年中，从一个新业务组出来，一时不知道要去哪个组好。在新业务组应该是最有干劲的时候，很多项目从0到1，学到不少东西。换组之后，感觉成长速度放慢了，脑子也开始想东想西。2019最忙的时候是11月。一边需求压身，一边准备简历。从开始复习到面试只有两周，这么赶是为了早点过去新环境以减少损失，毕竟年终奖没了。全程一共面了4家，印象比较深的是bigo和tx的终面，bigo技术终面是现场的电话面，没说错，在现场打电话，这是毕业后第一次被电话面，全程莫名紧张，面试官问的很深，面完以为自己跪了。tx终面时间挺短的，但是等待时间是最长的。从中午等到天黑，在tx办公室里，一边喝着咖啡一边在自己的mbp上刷算法，一度以为就是这里的员工了。总之，这几次的面试经历有趣又宝贵，也是一个认清自己的过程，让我知道哪方面不足还需要学习的，感谢面试官们这样虐我 = = 2020年2020年，充满希望的一年。主要是希望自己可以不那么懒，具体的目标和计划就不说了，我怕说出来就不灵了。","link":"/2020/01/23/2019年总结/"},{"title":"Android persistent机制","text":"本文简单分析persistent属性的相关源码流程，总结persistent的作用及注意事项。 前言在一次调试系统应用过程中，修改部分代码逻辑后，执行adb install -r 并启动，发现应用界面更新了，但是修改到的逻辑并没有变，还是之前的版本逻辑。分别执行了pm clear和am force-stop再起来应用，发现这两种做法进程id都没有变。于是直接kill掉对应进程id，发现进程id变了，进程重启了，但是发现修改到的逻辑还是没变…最后重启了一下机器？应用的界面和逻辑都正常更新了。 为什么呢？可以看一下此系统应用的manifest 12345678910111213141516&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" package=\"com.seewo.trunning\" android:sharedUserId=\"android.uid.system\"&gt; ... &lt;application android:name=\".TRunningApplication\" android:label=\"@string/app_name\" android:persistent=\"true\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; ... &lt;/application&gt;&lt;/manifest&gt; 原来是persistent属性在作怪。persistent有什么作用？看看官网解释： 可以知道，persistent表示此应用是可持久的，也就是常驻应用。官网的解释就这么多，下面只能从源码入手来了解persistent的原理，并解释上面例子的原因。 开机启动过程众所周知，带persistent属性的系统应用开机会自启动。并且persistent应用启动时机很早，早于Launcher启动及开机广播。可以看一下framework层是怎么做的？android系统开机启动时，AMS会调用到systemReady()，然后扫描所有安装的应用，并启动属性persistent为true的应用。 /frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678910111213141516171819202122232425262728293031323334public void systemReady(final Runnable goingCallback, TimingsTraceLog traceLog) &#123; ... synchronized (this) &#123; startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE); // Start up initial activity. mBooting = true; ... startHomeActivityLocked(currentUserId, \"systemReady\"); //0 ... &#125;&#125;void startPersistentApps(int matchFlags) &#123; if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) return; synchronized (this) &#123; try &#123; final List&lt;ApplicationInfo&gt; apps = AppGlobals.getPackageManager() .getPersistentApplications(STOCK_PM_FLAGS | matchFlags).getList(); //1 for (ApplicationInfo app : apps) &#123; if (!\"android\".equals(app.packageName)) &#123; addAppLocked(app, null, false, null /* ABI override */); &#125; &#125; &#125; catch (RemoteException ex) &#123; &#125; &#125;&#125; 上面注释0处，startHomeActivityLocked()会启动Launcher，晚于persistent应用的启动；注释1处，通过PMS的getPersistentApplications()方法获取persistent应用, 最后再通过addAppLocked()启动应用进程 /frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678910111213141516171819202122232425262728final ProcessRecord addAppLocked(ApplicationInfo info, String customProcess, boolean isolated, boolean disableHiddenApiChecks, String abiOverride) &#123; ... if ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123; app.persistent = true; app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ; //2 &#125; if (app.thread == null &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; 0) &#123; mPersistentStartingProcesses.add(app); startProcessLocked(app, \"added application\", //3 customProcess != null ? customProcess : app.processName, disableHiddenApiChecks, abiOverride); &#125; ...&#125;public final class ProcessList &#123; ... // This is a system persistent process, such as telephony. Definitely // don't want to kill it, but doing so is not completely fatal. static final int PERSISTENT_PROC_ADJ = -800; ...&#125; 上面主要做了两件事，注释2处设定进程adj为PERSISTENT_PROC_ADJ，值为-800，定义在ProcessList类中，表示进程属于高优先级，当系统资源紧张时，lowmemorykiller机制回收应用时会跳过persistent进程。注释3处就是启动进程了，startProcessLocked方法最后会发消息到zygote进程，然后fork出应用进程，这里不再深入。通过上面的步骤，android系统就在启动时预加载了persistent应用，并赋予了应用进程高优先级以保证持久性，但是，如果persistent应用被杀死或运行时异常崩溃，android如何对应用进行拉活？继续往下看。 重启机制android在进程启动后调用到attachApplicationLocked时会创建一个进程死亡监听器AppDeathRecipient /frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 12345678910111213141516171819202122232425262728private final boolean attachApplicationLocked(IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; ... try &#123; AppDeathRecipient adr = new AppDeathRecipient( app, pid, thread); thread.asBinder().linkToDeath(adr, 0); app.deathRecipient = adr; &#125; ...&#125;private final class AppDeathRecipient implements IBinder.DeathRecipient &#123; ... @Override public void binderDied() &#123; if (DEBUG_ALL) Slog.v( TAG, \"Death received in \" + this + \" for thread \" + mAppThread.asBinder()); synchronized(ActivityManagerService.this) &#123; appDiedLocked(mApp, mPid, mAppThread, true); //4 &#125; &#125;&#125; 当应用进程死亡时，系统会回调到死亡监听器的binderDied()方法，执行注释4处的appDiedLocked()做一些进程死亡后的相关善后工作。继续走下去，appDiedLocked()最终会执行到cleanUpApplicationRecordLocked()，我们可以看一下这个方法做了什么。 123456789101112131415161718192021private final boolean cleanUpApplicationRecordLocked(ProcessRecord app, boolean restarting, boolean allowRestart, int index, boolean replacingPid) &#123; ... if (!app.persistent || app.isolated) &#123; ... &#125; else if (!app.removed) &#123; // This app is persistent, so we need to keep its record around. // If it is not already on the pending app list, add it there // and start a new process for it. if (mPersistentStartingProcesses.indexOf(app) &lt; 0) &#123; mPersistentStartingProcesses.add(app); restart = true; &#125; &#125; ...&#125; 上面的注释很清楚，如果是persistent应用，会继续保留其进程记录，然后重新启动进程。当然，如果是persistent应用进程死亡，系统则直接回收所有的进程资源。到这里，我们可以了解到，当persistent应用被异常杀死时，系统通过进程死亡监听器来重启进程，并且过程中不会清理进程记录ProcessRecord。而ProcessRecord对象其实记录着进程的四大组件和进程状态等信息。 persistent带来的问题我们可以看到，系统应用声明persistent，可以开机立即加载进程，更快响应；可以保证一些关键应用常驻在系统中，不会被系统回收；比如长连接应用等。但是persistent的使用同时也会带来一些问题，如长期占用系统资源不释放；如果app出现不可恢复的crash，将陷入一直崩溃启动的死循环；应用自升级不会kill并清理进程，需要特殊处理，并且升级后会失去persistent特性。 系统应用自升级正常的应用自升级流程，覆盖安装时系统会kill应用进程并清理在AMS中的进程记录，在新版应用重新启动时，系统会新建一个进程并重新加载各种组件运行。但是，persistent应用自升级时，系统不会kill此应用进程，AMS也不会清理进程记录，系统只会把新版应用中的各种组件信息记录到AMS中，这样可能出现两个版本逻辑融合到一起，导致应用功能出现错乱。解决方法有，一种是应用自升级后重启系统，这样会重新加载进程，但是这个明显不符合需求，影响用户体验，不可取。第二种是接收新版应用的安装广播，调用context的startInstrumentation方法，会强制系统kill应用进程，清理AMS对各种组件的状态记录，并重新启动应用。 解决上面这个问题以后，还有一个问题，升级后的persistent系统应用会变成普通应用，导致后续失去persistent特性。 低端设备禁用硬件加速在低端设备上对于persistent进程会禁用硬件加速，下面代码注释已经说明了。android系统这么做，可能就是因为persistent应用是常驻的，这样可以避免占用太多的资源。 /frameworks/base/core/java/android/view/ViewRootImpl.java 123456789101112131415161718192021private void enableHardwareAcceleration(WindowManager.LayoutParams attrs) &#123; if (hardwareAccelerated) &#123; if (!ThreadedRenderer.isAvailable()) &#123; return; &#125; // Persistent processes (including the system) should not do // accelerated rendering on low-end devices. In that case, // sRendererDisabled will be set. In addition, the system process // itself should never do accelerated rendering. In that case, both // sRendererDisabled and sSystemRendererDisabled are set. When // sSystemRendererDisabled is set, PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED // can be used by code on the system process to escape that and enable // HW accelerated drawing. (This is basically for the lock screen.) final boolean fakeHwAccelerated = (attrs.privateFlags &amp; WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED) != 0; final boolean forceHwAccelerated = (attrs.privateFlags &amp; WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED) != 0; &#125; &#125; 其他问题回头看最开始的调试例子应该清楚了。说到应用界面更新了，但是修改到的逻辑并没有变，其实是因为刚好应用界面跑在子进程里，这也说明了persistent属性只能对应用主进程生效，子进程不生效。persistent进程的adj值是负数，普通进程一般大于等于0，我们可以直接查看进程adj来验证一下 可以发现，其中home进程是子进程，adj为0，是前台进程。应用主进程pid为1091，adj为-11，其优先级很高，是persistent进程。 总结 普通应用manifest中声明persistent属性是无效的，只有系统应用才能生效； persistent应用启动早于Launcher启动早于开机广播，开发中需要注意时序问题； persistent应用会一直常驻在系统中，进程资源不会被系统回收，应用异常退出后系统会立即重启应用，并保留进程记录； persistent应用自升级需要做特殊处理。所以，开发中覆盖安装persistent应用后，必须重启android设备才能正常运行最新代码。当然，第一次覆盖安装后，该应用会失去persistent特性。 persistent应用的子进程不具备persistent特性；","link":"/2019/03/06/Android persistent机制/"},{"title":"Android分屏多窗口实现","text":"前言基于公司产品的要求，需要研究app如何在Android N中支持分屏模式。以下是自己思路的总结，也顺便帮助到各位。 概述Android N 的新特性就是对应用分屏的支持。在分屏模式中，系统以左右并排或上下并排的方式分屏显示两个应用。用户可以通过拖动两个应用之间的分界线来改变两个应用的尺寸。 用户可以通过以下方式切换到分屏模式： 打开 Overview 屏幕并长按 Activity 标题，则可以拖动该 Activity 至屏幕突出显示的区域，使Activity 进入多窗口模式。 长按 Overview 按钮，设备上的当前 Activity 将进入分屏模式，同时将打开 Overview 屏幕，可在该屏幕中选择要共享屏幕的另一个 Activity。 另外，用户可以在两个 Activity 共享屏幕的同时在这两个 Activity 之间拖放数据 分屏模式下的生命周期首先，分屏模式并没有改变Activity的生命周期。在分屏模式中，与用户交互的 Activity 为活动状态。另一个 Activity 虽然可见，但处于暂停状态。 如果用户与此暂停的 Activity 交互，该 Activity 将恢复，而之前的Activity 将暂停。所以，在分屏模式下，应用在对用户可见的状态下进入paused状态，可能仍需要继续其操作。就如一个视频播放器，如果进入了分屏模式，不应该在onPaused()中暂停视频播放，而应该在onStop()中才暂停视频，然后对应的在onStart中恢复视频播放。 另外，在Android N的Activity类中，增加了一个void onMultiWindowChanged(boolean inMultiWindow)回调，Activity 进入或退出分屏模式时系统将调用此方法。 在 Activity进入分屏模式时，系统向该方法传递 true 值，在退出分屏模式时，则传递 false 值。 #处理运行时变更在分屏模式显示应用，调整应用大小，或将应用恢复到全屏模式时，系统将通知 Activity 发生配置变更。这与横竖屏切换时的 Activity 生命周期影响相同，即Activity会重启(调用onPause–&gt;onStop–&gt;onDestory–&gt;onCreate–&gt;onStart–&gt;onResume),为了分屏后使Activity恢复原来的状态，一般有两种方法。一是在Activity重启前保存数据；二是阻止Activity的重启。 在Activity重启前保存数据 1、通过onSaveInstanceState()保存bundle数据,以保证该状态可以在onCreate(Bundle)或者onRestoreInstanceState(Bundle)中恢复2、重启 Activity需要恢复大量数据、重新建立网络连接等，那么因配置变更而引起的Activity重启会很缓慢，这时可以通过保存 Fragment来减轻重新初始化 Activity的负担，具体做法是，在Activity中包含此Fragment的引用，而Fragment包含要保存的对象的引用；接着，通过在Fragment的onCreate方法中设置setRetainInstance(true)对Fragment进行非中断式的保存；这样，当Activity被销毁重启时，fragment实例还在，可以Activity中恢复了对fragment的引用从而恢复数据。具体可参考处理运行时变更。 阻止Activity的重启 在清单文件中声明： 1234&lt;activity android:name=&quot;.MyActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:label=&quot;@string/app_name&quot;&gt; android:configChanges属性最常用的值包括 “orientation” ， “keyboardHidden”和”screenSize”，分别用于避免因屏幕方向，可用键盘改变和屏幕尺寸而导致重启。这种方法不同于第一种，系统不会自动根据当前的配置去应用资源。所以如果需要的话，要在onConfigurationChanged()中自行设置备用资源，即通过setContentView()去调用相应的layout文件。不需要基于这些配置变更去更新应用，则可不用实现onConfigurationChanged()。 注意，第二种方法官方不推荐使用，主要是因为Activity销毁重启不仅仅在分屏模式下会出现，比如手机内存不够时Activity同样可能被销毁，而这时候我们还是需要在Activity销毁前做好数据状态的保存。当然，如果没有备用资源的话，也就是Activity横向和纵向都共用同一个layout文件，则第二种方法无疑是更好的选择。 配置分屏模式在清单的activity或application节点中设置该属性，启用或禁用分屏显示： android:resizeableActivity=[&quot;true&quot; | &quot;false&quot;] 如果该属性设置为 true，Activity 将能以分屏和自由形状模式启动。 如果此属性设置为 false，Activity 将不支持多窗口模式。如果该值为 false，且用户尝试在分屏模式下启动 Activity，该 Activity 将全屏显示。 如果应用没有适配到Android N（targetSDKVersion &lt; AndroidN，compileSDKVersion &lt; Android N)，也是可以支持分屏的。系统将强制调整应用大小。不过会显示对话框提醒用户应用可能会发生异常。 另外，在Android N中，可以在清单文件中添加layout节点，并设置一些新增加的属性，通过这些属性来设置分屏模式的行为，如最小尺寸等例如，以下节点显示了如何指定 Activity 在自由形状模式中显示时 Activity 的默认大小、位置和最小尺寸： 1234567&lt;activity android:name=&quot;.MyActivity&quot;&gt; &lt;layout android:defaultHeight=&quot;500dp&quot; android:defaultWidth=&quot;600dp&quot; android:gravity=&quot;top|end&quot; android:minimalHeight=&quot;450dp&quot; android:minimalWidth=&quot;300dp&quot; /&gt;&lt;/activity&gt; 参考https://developer.android.com/preview/features/multi-window.html#configuringhttp://blog.csdn.net/airk000/article/details/38557605","link":"/2016/07/29/Android分屏多窗口实现/"},{"title":"Cocos2d-x入门及Android原生平台发布","text":"0、前言本文简单介绍了Cocos2d-x的基本概念以及Cocos Creator开发环境搭建和入门，最后是Android平台的发布和打包。 1、Cocos2d-x 是什么Cocos2d-x 是一款开源的跨平台游戏引擎，支持C++，Lua和JavaScript语言；Cocos2d 有很多个分支，蓝色区域是目前的主流解决方案。 1-1、Cocos2d与Unity3dUnity3d： 适合3d游戏，大型2d游戏 Unity3d引擎更强大，可以做更多事件，比如VR，AR 要收费 Cocos2d： 适合小型2d游戏 相比Unity3d速度快，安装包小 免费开源 可能会踩坑较多 1-2、其他游戏引擎 Libgdx AndEngine Unreal Corona…… 1-3、Cocos2d-x与OpenGL ES、DirectX1）Cocos2d-x 的图形渲染基于OpenGL ES2）Cocos2d-x 还包含其他如资源管理，音频播放、物理引擎等模块，比直接使用 OpenGL ES 开发游戏，更加迅速简单。让开发者将精力集中在游戏本身，而不是底层的图像绘制上。3）DirectX是Windows平台图形编程接口，Cocos2d-x通过AngleProject间接支持windows平台，AngleProject的作用是将OpenGL ES转化为DirectX 所以，Cocos2d-x的跨平台特性其实也就是借助了OpenGL ES的跨平台性，从而横跨iOS, Android, WP8三个主要平台。 2、开发环境Cocos Creator：类似于 Unity3D 的游戏编辑器，并且内部已经包含完整的 JavaScript 引擎和 cocos2d-x 原生引擎 VS Code (WebStorm、SublimeText):JavaScript脚本代码编辑器 下图是mac平台显示Cocos Creator包内容的目录： Android原生平台配置： 注：js引擎和cocos2d-x引擎在Cocos Creator已经自带了，不用我们配置。另外，使用android studio也要配置ANT路径。 3、关于Cocos Creator 组件化 脚本化 数据驱动 跨平台发布 Cocos Creator 的技术架构图 3-1、组件化概念Cocos Creator 工作流以组件化开发为核心，也就是基于组件的实体系统开发模式 (Entity-Component System)。简单的说，就是以组合而非继承的方式进行实体的构建。 一个实体指的是存在于游戏世界中的物体，多个组件可以挂载到实体上，比如动画组件，碰撞组件，渲染组件等。 3-2、数据驱动代替代码驱动 所有场景都会序列化为数据，在运行时使用这些数据来重新构建场景，界面，动画等元素。 数据驱动实现了场景的可视化，使得场景可以被自由的编辑。从而使入口点变成了编辑器，而不是代码。 4、脚本组件开发4-1、基本概念 导演和场景场景相当于一部电影的某个场景画面，导演就负责画面的切换。 节点和组件把功能点设计封装成组件(Component)的形式，然后将这些组件，按需挂载到一个个类似于容器的节点上，从而形成一个个功能各异的实体(Entity) 4-2、简单的脚本示例12345678910111213141516171819202122cc.Class(&#123; extends: cc.Component, //属性声明，会展示在属性检查器中 properties: &#123; username: &quot;Devnan&quot;, //基本JavaScript类型, string age: 18, //基本JavaScript类型, number girlFriend: cc.Node //cc类型，cc.Node用于获取其他节点(实体) &#125;, //构造函数 ctor: function () &#123; &#125; // 首次加载，做初始化操作 onLoad: function () &#123; &#125;, // 每一帧渲染都会调用此函数进行更新 update: function (dt) &#123; &#125;,&#125;); 4-3、生命周期 onLoad：组件首次激活时触发，在 start 调用前执行，一般做初始化操作 start：第一次执行 update 前触发，初始化一些可能在update时发生改变的中间状态 update：每一帧渲染前触发，做更新操作 lateUpdate：update 执行完之后触发，做动画更新后的一些额外操作 onDestroy：当组件或者所在节点调用了destroy()，则会调用此回调，并做回收操作…… 4-4、事件分发机制 node.on(type, callback, target)：持续监听 node 的 type 事件。 node.once(type, callback, target)：监听一次 node 的 type 事件。 node.off(type, callback, target)：取消监听所有 type 事件或取消 type 的某个监听器（用 callback 和 target 指定）。 node.emit(type, detail)：通知所有监听 type 事件的监听器，可以发送一个附加参数。 node.dispatchEvent(event)：发送一个事件给它的监听器，支持冒泡。 node.dispatchEvent 采用冒泡派送的方式分发事件。冒泡派送会将事件从事件发起节点，不断地向上传递给他的父级节点，直到到达根节点或者在某个节点通过event.stopPropagation() 拦截了此事件。 触摸事件也支持节点树的事件冒泡。 注：和android的事件分发机制有差别，cocos2d没有事件捕获的过程，而且消费事件后需要主动去拦截事件传递 5、其他组件 物理组件 动画组件…… 6、构建发布流程 link、default：使用源码引擎构建，速度慢 binary：使用预编译库构建，无需编译C++，速度快，但是无法在原生工程里调试引擎源码 下面目录可以拿到构建编译后android平台下的apk 这样是不是都搞定了？可以开心地玩游戏了 最后还要导入到原生平台Android Studio进行开发，以修改一些默认配置，比如应用图标，混淆开关等 这里可以用脚本处理整个流程，从构建编译，导出原生平台，到部分配置项的修改，以加快打包速度。 可以在工程主目录新建android-build文件夹，builder.json是构建编译的配置文件，build.sh是整个流程的脚本，如下， 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env bashPROJECT_PATH=$(dirname `pwd`)# 构建编译buildCompile()&#123; echo &quot;PROJECT_PATH:&quot; $PROJECT_PATH /Applications/CocosCreator.app/Contents/MacOS/CocosCreator --path $PROJECT_PATH --build &quot;configPath=$PROJECT_PATH/android-build/builder.json;autoCompile=true&quot;&#125; handleAndroidProject() &#123; # 适配环境 echo &quot;android.enableAapt2=false&quot; &gt;&gt; $ANDROID_PATH&quot;/gradle.properties&quot; # 替换资源 ANDROID_PATH=$PROJECT_PATH&quot;/build/jsb-binary/frameworks/runtime-src/proj.android-studio&quot; RES_PATH=$&#123;ANDROID_PATH&#125;&quot;/app/res&quot; echo &quot;ANDROID_PATH:&quot; $ANDROID_PATH echo &quot;replace $RES_PATH/values/strings.xml&quot; rm $RES_PATH&quot;/values/strings.xml&quot; cp ./res/strings.xml $RES_PATH&quot;/values/&quot; echo &quot;replace $RES_PATH/mipmap-xhdpi/ic_launcher.png&quot; rm $RES_PATH&quot;/mipmap-xhdpi/ic_launcher.png&quot; cp ./res/ic_launcher.png $RES_PATH&quot;/mipmap-xhdpi/&quot; rm $RES_PATH&quot;/mipmap-xxhdpi/ic_launcher.png&quot; cp ./res/ic_launcher.png $RES_PATH&quot;/mipmap-xxhdpi/&quot;&#125;# 重新打包generateAPK()&#123; cd $ANDROID_PATH/app/ gradle clean assembleRelease mkdir $PROJECT_PATH/android-build/apk cp $ANDROID_PATH/app/build/outputs/apk/release/*.apk $PROJECT_PATH/android-build/apk echo &quot;regenerate apk in $PROJECT_PATH/android-build/apk&quot;&#125;# 执行流程buildCompilehandleAndroidProjectgenerateAPK 7、推荐资料 Cocos Creator v1.8.x 用户手册http://docs.cocos.com/creator/manual/zh/ Cocos Creator 之旅：http://www.cocos.com/607","link":"/2018/01/26/Cocos2d-x入门及Android原生平台发布/"},{"title":"内存泄漏之库工程集成LeakCanary","text":"业务项目中采用模块化的架构，需要在每个模块集成LeakCanary，这样可以在模块的开发调试阶段发现内存泄漏问题，比较好的做法是把LeakCanary下沉到基础的库工程中。 问题1. 库工程默认只会发布release包，官网的集成依赖方式是release采用no-op空实现，所以需要对库工程做处理注：gradle插件3.0之后可以发布所有变种包，不存在问题1。网上很多资料会误导，可以参考 https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html LeakCanary的泄漏分析是在子进程中，app依赖库工程后，需要避免application重复初始化解决方案问题1：(gradle插件3.0之前)有两种解决办法1、第一种可以采用官网的依赖方式。由于releaseImplementation是空实现，而库工程默认只会发布release包，导致leakcanary失效。 1234dependencies &#123; debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.3' releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3'&#125; 我们需要对库工程打包多个变种，设置publishNonDefault可以生成所有变种包。这样app就可以区分不同的构建类型进行依赖。 1234567apply plugin: 'com.android.library'android &#123; ... publishNonDefault true&#125; app依赖方式如下，让app工程在debug版本下依赖库工程debug版本，在release版本下依赖库工程release版本 1234dependencies &#123; debugImplementation project(path: ':myLibrary', configuration: 'debug') releaseImplementation project(path: ':myLibrary', configuration: 'release')&#125; 2、第二种方法，使用依赖如下： 123dependencies &#123; implementation 'com.squareup.leakcanary:leakcanary-android:1.6.3'&#125; 基础库工程抽离一个BaseApplication做初始化的公共操作。如果release版本则不初始化LeakCanary，代替了第一种方法中releaseImplementation的空实现方式。需要注意的是，库工程BuildConfig.debug一直为false，需要在app工程中判断是否调试版本。项目工程采用了这种方法。 123456789101112131415161718192021222324252627282930abstract class BaseApplication : Application() &#123; companion object &#123; private val TAG = this::class.java.simpleName &#125; override fun onCreate() &#123; super.onCreate() if (isDebug()) &#123; if (LeakCanary.isInAnalyzerProcess(this)) &#123; // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. logd(TAG, \"LeakCanary process is starting for heap analysis\") return &#125; LeakCanary.refWatcher(this) .listenerServiceClass(LeakService::class.java) .buildAndInstall() logd(TAG, \"LeakCanary installed\") &#125; // Normal app init code... &#125; /** * 是否为调试版本，需要在app工程判断 */ abstract fun isDebug(): Boolean&#125; 问题2：由于LeakCanary堆分析是另起子进程进行的，会重新触发application的onCreate。需要记得在子进程中return掉以避免重复初始化。 123456if (LeakCanary.isInAnalyzerProcess(this)) &#123; // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return;&#125; 我们想把LeakCanary的逻辑放到基础库工程，app工程不需要关心这些操作。所以设计如下， 12345678910111213141516171819202122232425262728293031323334353637383940abstract class BaseApplication : Application() &#123; companion object &#123; private val TAG = this::class.java.simpleName &#125; final override fun onCreate() &#123; super.onCreate() if (isDebug()) &#123; if (LeakCanary.isInAnalyzerProcess(this)) &#123; // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. logd(TAG, \"LeakCanary process is starting for heap analysis\") return &#125; LeakCanary.refWatcher(this) .listenerServiceClass(LeakService::class.java) .buildAndInstall() logd(TAG, \"LeakCanary installed\") &#125; //公共初始化... //子类application初始化，为了避免在LeakCanary子进程中重复初始化 onAppCreate() &#125; /** * 子类application初始化 */ abstract fun onAppCreate() /** * 是否为调试版本，需要在app工程判断 */ abstract fun isDebug(): Boolean&#125; 在app工程中继承BaseApplication 12345678910class Application : BaseApplication &#123; override fun onAppCreate() &#123; //no-op &#125; override fun isDebug(): Boolean &#123; return BuildConfig.DEBUG; &#125;&#125; 以上，是库工程集成LeakCanary的一种实现方案，有更好的设计可以留言交流。","link":"/2019/04/02/内存泄漏之库工程集成LeakCanary/"}],"tags":[{"name":"总结","slug":"总结","link":"/tags/总结/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"内存泄漏","slug":"内存泄漏","link":"/tags/内存泄漏/"}],"categories":[]}